<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>全屏粒子沉浸展示</title>
    <style>
        /* --- 关键修改 1：强制全屏黑底 --- */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000; /* 纯黑背景，解决留白问题 */
            overflow: hidden; /* 隐藏滚动条 */
        }
        canvas {
            display: block; /* 消除 canvas 底部潜在的缝隙 */
            /* canvas 的具体尺寸将由 JS 动态设置 */
        }
    </style>
</head>
<body>
    <canvas id="myCanvas"></canvas>

    <script>
        // --- 核心引擎 (纯原生 JS，修改为全屏适配版) ---
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        
        let width, height, centerX, centerY, fov;

        // --- 关键修改 3：动态调整尺寸以适应全屏 ---
        function resize() {
            // 获取浏览器窗口的内部宽高
            width = window.innerWidth;
            height = window.innerHeight;
            // 设置画布尺寸等于窗口尺寸
            canvas.width = width;
            canvas.height = height;
            // 重新计算中心点和焦距
            centerX = width / 2;
            centerY = height / 2;
            // 根据屏幕大小调整焦距 (Field of View)，保证视觉效果一致
            fov = Math.min(width, height) * 0.8;
        }
        // 监听窗口大小改变事件（适应屏幕旋转或缩放）
        window.addEventListener('resize', resize);
        // 初始化时先执行一次
        resize();

        // 粒子参数
        const particles = [];
        // 稍微增加粒子数量以填充更大的屏幕
        const PARTICLE_COUNT = 800; 

        // 初始化粒子数据
        for(let i=0; i<PARTICLE_COUNT; i++) {
            particles.push({
                // 目标位置 (球体形态)
                tx: (Math.random()-0.5) * 250, 
                ty: (Math.random()-0.5) * 250, 
                tz: (Math.random()-0.5) * 250,
                // 散开位置 (乱序，范围加大适应全屏)
                rx: (Math.random()-0.5) * 1500,
                ry: (Math.random()-0.5) * 1500,
                rz: (Math.random()-0.5) * 1500,
                // 颜色采用截图中那种蓝紫色调
                color: `hsl(${Math.random()*60 + 190}, 100%, 65%)`,
                baseSize: Math.random() * 2 + 0.5 // 基础大小
            });
        }

        // 修正为更标准的球体分布
        for(let p of particles) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            const r = 180; // 球体半径
            p.tx = r * Math.sin(phi) * Math.cos(theta);
            p.ty = r * Math.sin(phi) * Math.sin(theta);
            p.tz = r * Math.cos(phi);
        }

        // 交互状态
        let mouseXRatio = 0.5; // 默认在中间

        // 鼠标移动监听
        window.addEventListener('mousemove', e => {
            mouseXRatio = e.clientX / width;
        });
        // 增加移动端触摸滑动支持
        window.addEventListener('touchmove', e => {
             if(e.touches.length > 0) {
                // 阻止默认滚动行为
                e.preventDefault();
                mouseXRatio = e.touches[0].clientX / width;
             }
        }, { passive: false });

        // 动画循环
        let angle = 0;
        let currentProgress = 0.5;

        function animate() {
            // 使用半透明黑色清空画布，制造拖尾效果
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, width, height);

            angle += 0.003; // 缓慢旋转
            const sin = Math.sin(angle);
            const cos = Math.cos(angle);
            
            // 平滑插值交互值
            currentProgress += (mouseXRatio - currentProgress) * 0.05;
            
            // 绘制粒子
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const p = particles[i];

                // 计算当前位置 (插值)
                let cx = p.rx + (p.tx - p.rx) * currentProgress;
                let cy = p.ry + (p.ty - p.ry) * currentProgress;
                let cz = p.rz + (p.tz - p.rz) * currentProgress;

                // 绕Y轴旋转
                let rotX = cx * cos - cz * sin;
                let rotZ = cz * cos + cx * sin;
                let rotY = cy;

                // 3D透视投影核心公式
                // 摄像机位于 z = -fov 处
                const scale = fov / (fov + rotZ);

                // 只绘制在摄像机前方的粒子
                if (scale > 0) {
                    const screenX = rotX * scale + centerX;
                    const screenY = rotY * scale + centerY;
                    
                    // 根据距离调整粒子大小
                    const size = p.baseSize * scale;

                    ctx.beginPath();
                    ctx.fillStyle = p.color;
                    ctx.arc(screenX, screenY, size, 0, Math.PI*2);
                    ctx.fill();
                }
            }
            requestAnimationFrame(animate);
        }
        
        // 启动动画
        animate();
    </script>
</body>
</html>
